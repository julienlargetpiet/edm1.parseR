
<!DOCTYPE html><html><head><title>R: depth_pairs_findr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>depth_pairs_findr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>depth_pairs_findr</h2>

<h3>Description</h3>

<p>Takes the pair vector as an input and associate to each pair a level of depth, see examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth_pairs_findr(inpt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the pair vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(depth_pairs_findr(c(1, 1, 2, 3, 3, 4, 4, 2, 5, 6, 7, 7, 6, 5)))

 [1] 1 1 1 2 2 2 2 1 1 2 3 3 2 1

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_findr_merger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_findr_merger</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_findr_merger</h2>

<h3>Description</h3>

<p>Takes two different outputs from pairs_findr and merge them. Can be usefull when the pairs consists in different patterns, for example one output from the pairs_findr function with ptrn1 = &quot;(&quot; and ptrn2 = &quot;)&quot;, and a second output from the pairs_findr function with ptrn1 = &quot;&quot; and ptrn2 = &quot;&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_findr_merger(lst1 = list(), lst2 = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lst1">lst1</code></td>
<td>
<p>is the first ouput from pairs findr function</p>
</td></tr>
<tr><td><code id="lst2">lst2</code></td>
<td>
<p>is the second ouput from pairs findr function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 8, 9)), 
                         lst2=list(c(1, 1), c(1, 2))))

[[1]]
[1] 1 1 2 3 4 4 3 2

[[2]]
[1] 1 2 3 4 5 7 8 9

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 8, 9)), 
                         lst2=list(c(1, 1), c(1, 11))))

[[1]]
[1] 1 2 3 4 4 3 2 1

[[2]]
[1]  1  3  4  5  7  8  9 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 8, 10, 11)), 
                         lst2=list(c(4, 4), c(6, 7))))

[[1]]
[1] 1 2 3 4 4 3 2 1

[[2]]
[1]  3  4  5  6  7  8 10 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 10, 11)), 
                         lst2=list(c(4, 4), c(8, 9))))

[[1]]
[1] 1 2 3 3 4 4 2 1

[[2]]
[1]  3  4  5  7  8  9 10 11

print(pairs_findr_merger(lst1=list(c(1, 2, 3, 3, 2, 1), c(3, 4, 5, 7, 10, 11)), 
                         lst2=list(c(4, 4), c(18, 19))))

[[1]]
[1] 1 2 3 3 2 1 4 4

[[2]]
[1]  3  4  5  7 10 11 18 19

print(pairs_findr_merger(lst1 = list(c(1, 1, 2, 2, 3, 3), c(1, 25, 26, 32, 33, 38)), 
                        lst2 = list(c(1, 1, 2, 2, 3, 3), c(7, 11, 13, 17, 19, 24))))

[[1]]
 [1] 1 2 2 3 3 4 4 1 5 5 6 6

[[2]]
 [1]  1  7 11 13 17 19 24 25 26 32 33 38

print(pairs_findr_merger(lst1 = list(c(1, 1, 2, 2, 3, 3), c(2, 7, 9, 10, 11, 15)), 
                         lst2 = list(c(3, 2, 1, 1, 2, 3, 4, 4), c(1, 17, 18, 22, 23, 29, 35, 40))))

[[1]]
 [1] 6 5 1 1 2 2 3 3 4 4 5 6 7 7

[[2]]
 [1]  1  2  7  9 10 11 15 17 18 22 23 29 35 40

print(pairs_findr_merger(lst1 = list(c(1, 1), c(22, 23)), 
                         lst2 = list(c(1, 1, 2, 2), c(3, 21, 27, 32))))

[[1]]
[1] 1 1 2 2 3 3

[[2]]
[1]  3 21 22 23 27 32

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_findr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_findr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_findr</h2>

<h3>Description</h3>

<p>Takes a character as input and detect the pairs of pattern, like the parenthesis pais if the pattern is &quot;(&quot; and then &quot;)&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_findr(inpt, ptrn1 = "(", ptrn2 = ")")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character</p>
</td></tr>
<tr><td><code id="ptrn1">ptrn1</code></td>
<td>
<p>is the first pattern ecountered in the pair</p>
</td></tr>
<tr><td><code id="ptrn2">ptrn2</code></td>
<td>
<p>is the second pattern in the pair</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_findr(inpt="ze+(yu*45/(jk+zz)*(o()p))-(re*(rt+qs)-fg)"))

[[1]]
 [1] 4 1 1 3 2 2 3 4 6 5 5 6

[[2]]
 [1]  4 11 17 19 21 22 24 25 27 31 37 41

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_insertr2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_insertr2</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_insertr2</h2>

<h3>Description</h3>

<p>Takes a character representing an arbitrary condition (like ReGeX for example) or an information (to a parser for example), vectors containing all the pair of pattern that potentially surrounds condition (flagged_pair_v and corr_v), and a vector containing all the conjuntion character, as input and returns the character with all or some of the condition surrounded by the pair characters. See examples. All the pair characters are inserted according to the closest pair they found priotizing those found next to the condition and on the same depth-level and , if not found, the pair found at the n+1 depth-level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_insertr2(
  inpt,
  algo_used = c(1:3),
  flagged_pair_v = c(")", "]"),
  corr_v = c("(", "["),
  flagged_conj_v = c("&amp;", "|"),
  method = c("(", ")")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character representing an arbitrary condition, like ReGex for example, or information to a parser for example</p>
</td></tr>
<tr><td><code id="algo_used">algo_used</code></td>
<td>
<p>is a vector containing one or more of the 3 algorythms used. The first algorythm will simply put the pair of parenthesis at the condition surrounded and/or after a character flagged (in flagged_conj_v) as a conjunction. The second algorythm will put parenthesis at the condition that are located after other conditions that are surrounded by a pair. The third algorythm will put a pair at all the condition, it is very powerfull but takes a longer time. See examples and make experience to see which combination of algorythm(s) is the most efficient for your use case.</p>
</td></tr>
<tr><td><code id="flagged_pair_v">flagged_pair_v</code></td>
<td>
<p>is a vector containing all the first character of the pairs</p>
</td></tr>
<tr><td><code id="corr_v">corr_v</code></td>
<td>
<p>is a vector containing all the last character of the pairs</p>
</td></tr>
<tr><td><code id="flagged_conj_v">flagged_conj_v</code></td>
<td>
<p>is a vector containing all the conjunction character</p>
</td></tr>
<tr><td><code id="method">method</code></td>
<td>
<p>is length 2 vector containing as a first index, the first character of the pair inserted, and at the last index, the second and last character of the pair</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_insertr2(inpt = "([one]|two|twob)three(four)", algo_used = c(1), method = c("(", ")")))

[1] "([one]|(two)|(twob))three(four)"

print(pairs_insertr2(inpt = "([one]|two|twob)three(four)", algo_used = c(1), method = c("[", "]")))

[1] "([one]|[two]|[twob])three(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2)))

[1] "(oneA|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2), method = c("-", "#"),
                     flagged_pair_v = c(")", "]", "#"), corr_v = c("(", "[", "-")))

[1] "(oneA|[one]|-two#|-twob#)-three#(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2, 3)))

[1] "((oneA)|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(3), method = c("[", "]")))

[1] "([oneA]|[one]|[two]|[twob])[three](four)"

print(pairs_insertr2(inpt = "(oneA|[one]|two|twob)three((four))", algo_used = c(3)))

[1] "((oneA)|[one]|(two)|(twob))(three)((four))"

</code></pre>

</main>

</div>
</body></html>
<!DOCTYPE html><html><head><title>R: pairs_insertr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container"><main>

<table style="width: 100%;"><tr><td>pairs_insertr</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>pairs_insertr</h2>

<h3>Description</h3>

<p>Takes a character representing an arbitrary condition (like ReGeX for example) or an information (to a parser for example), vectors containing all the pair of pattern that potentially surrounds condition (flagged_pair_v and corr_v), and a vector containing all the conjuntion character, as input and returns the character with all or some of the condition surrounded by the pair characters. See examples. All the pair characters are inserted according to the closest pair they found priotizing those found next to the condition and on the same depth-level and , if not found, the pair found at the n+1 depth-level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_insertr(
  inpt,
  algo_used = c(1:3),
  flagged_pair_v = c(")", "]"),
  corr_v = c("(", "["),
  flagged_conj_v = c("&amp;", "|")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpt">inpt</code></td>
<td>
<p>is the input character representing an arbitrary condition, like ReGex for example, or information to a parser for example</p>
</td></tr>
<tr><td><code id="algo_used">algo_used</code></td>
<td>
<p>is a vector containing one or more of the 3 algorythms used. The first algorythm will simply put the pair of parenthesis at the condition surrounded and/or after a character flagged (in flagged_conj_v) as a conjunction. The second algorythm will put parenthesis at the condition that are located after other conditions that are surrounded by a pair. The third algorythm will put a pair at all the condition, it is very powerfull but takes a longer time. See examples and make experience to see which combination of algorythm(s) is the most efficient for your use case.</p>
</td></tr>
<tr><td><code id="flagged_pair_v">flagged_pair_v</code></td>
<td>
<p>is a vector containing all the first character of the pairs</p>
</td></tr>
<tr><td><code id="corr_v">corr_v</code></td>
<td>
<p>is a vector containing all the last character of the pairs</p>
</td></tr>
<tr><td><code id="flagged_conj_v">flagged_conj_v</code></td>
<td>
<p>is a vector containing all the conjunction character</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
print(pairs_insertr(inpt = "([one]|two|twob)three(four)", algo_used = c(1)))

[1] "([one]|[two]|[twob])three(four)"

print(pairs_insertr(inpt = "(one|[two]|twob)three(four)", algo_used = c(2)))

[1] "(one|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2)))

[1] "(oneA|[one]|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(1, 2, 3)))

[1] "([oneA]|[one]|[two]|[twob])(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three(four)", algo_used = c(3)))

[1] "([oneA]|[one]|(two)|(twob))(three)(four)"

print(pairs_insertr(inpt = "(oneA|[one]|two|twob)three((four))", algo_used = c(3)))

[1] "([oneA]|[(one)]|(two)|(twob))(three)((four))"

</code></pre>

</main>

</div>
</body></html>
